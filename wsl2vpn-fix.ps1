
function GetNetworkAddress {
    param (
        [string]$wslIPaddress,
        [int]$wslPrefixLength,
        [int]$vpnInterfaceNumber,
        [string]$vpnDescription
    )
    # Calculate the network address from the IP address and subnet prefix length
    if ($wslIPaddress) {
        # Get the subnet mask for the ipAddress
        $subnetBits = $wslPrefixLength
        $subnetMaskBinary = '1' * $subnetBits + '0' * (32 - $subnetBits)

        # Convert subnet mask binary to dotted-decimal notation
        $subnetMaskDottedDecimal = ''
        for ($i = 0; $i -lt 4; $i++) {
            $subnetMaskDottedDecimal += [convert]::ToByte($subnetMaskBinary.Substring($i * 8, 8), 2)
            if ($i -lt 3) { $subnetMaskDottedDecimal += '.' }
        }

        # Get network address from ipAddress and subnet mask
        $ipAddressBytes = [System.Net.IPAddress]::Parse($wslIPaddress).GetAddressBytes()
        $subnetMaskBytes = [System.Net.IPAddress]::Parse($subnetMaskDottedDecimal).GetAddressBytes()

        # Check if arrays are not null before accessing elements
        if ($null -ne $ipAddressBytes -and $null -ne $subnetMaskBytes) {
            $networkAddressBytes = @()
            for ($i = 0; $i -lt 4; $i++) {
                $networkAddressBytes += $ipAddressBytes[$i] -band $subnetMaskBytes[$i]
            }

            $wslNetworkAddress = [System.Net.IPAddress]::new($networkAddressBytes).ToString()

        }
        else {
            Write-Output "Failed to retrieve IP address or subnet mask bytes."
        }
    }
    else {
        Write-Output "Subnet mask cannot be calculated due to missing IP address."
    }
    return $wslNetworkAddress
}

function DeleteNetworkRoute {
    param (
        [string]$wslNetworkAddress,
        [int]$wslPrefixLength,
        [int]$vpnInterfaceNumber
    )

    $DestinationPrefix = $wslNetworkAddress + "/" + $wslPrefixLength.ToString()
    if ($vpnInterfaceNumber -and $DestinationPrefix) {
        $vpnInterfaceNumber = [int]$vpnInterfaceNumber
        # Check if the network of the WSL2 instance has a route to the VPN interface.
        Write-Output "Route for network $DestinationPrefix with interface number $vpnInterfaceNumber found."

        $loopCount = 0
        while ((Get-NetRoute -ErrorAction Stop | Where-Object { $_.DestinationPrefix -eq $DestinationPrefix -and $_.InterfaceIndex -eq $vpnInterfaceNumber }) -and $loopCount -lt 3) {
            if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
                # Run as Administrator else exit.
                Write-Output "This script must be run as an Administrator. Please re-run this script as an Administrator."
                exit
            }
            else {
                if (-not (Get-NetRoute -ErrorAction SilentlyContinue -DestinationPrefix $DestinationPrefix -InterfaceIndex $wslAdapter.InterfaceIndex)) {
                    # Add a route when using the Juniper Networks Virtual Adapter
                    Write-Output "Adding a route when using the Juniper Networks Virtual Adapter."
                    New-NetRoute -PolicyStore ActiveStore -DestinationPrefix $DestinationPrefix -InterfaceIndex $wslAdapter.InterfaceIndex -NextHop 0.0.0.0 | Format-Table -Property DestinationPrefix, InterfaceIndex, NextHop -AutoSize
                }
                Write-Output "Deleting route for network address $wslNetworkAddress with interface number $vpnInterfaceNumber."
                Remove-NetRoute -DestinationPrefix $DestinationPrefix -NextHop 0.0.0.0 -InterfaceIndex $vpnInterfaceNumber -PolicyStore "ActiveStore" -Confirm:$false
            }
            $loopCount++
            Start-Sleep -Seconds $loopCount
        }
    }
}

function GetDNSConfiguration {
    # Not used as DNS problems are fixed for me.
    # /etc/wsl.conf
    #[network]
    #generateHosts = false
    #generateResolvConf = true
    #
    # $USERPROFILE\.wslconfig
    #[wsl2]
    #guiApplications=true
    #dnsProxy=false
    #dnsTunneling=true
    #[experimental]
    #useWindowsDnsCache=true 

    #wsl -v   
    #WSL version: 2.0.14.0
    #Kernel version: 5.15.133.1-1
    #WSLg version: 1.0.59
    #MSRDC version: 1.2.4677
    #Direct3D version: 1.611.1-81528511
    #DXCore version: 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp
    #Windows version: 10.0.22000.2777

    param (
        [int]$vpnInterfaceNumber
    )

    $vpnDNSClient = Get-DnsClientGlobalSetting
    $vpnDNSServers = Get-DnsClientServerAddress -AddressFamily IPv4 | Where-Object { $_.InterfaceIndex -eq $vpnAdapter.InterfaceIndex } 

    $resolvConf = @"
# Generated by PowerShell
# DNS Suffix Search List
$($vpnDNSClient.SuffixSearchList -join ' ')

# DNS Servers
$(($vpnDNSServers.ServerAddresses | ForEach-Object { "nameserver $_" }) -join "`n")
"@

    $wslHost = "Ubuntu-22.04"
    # Copy $resolvConf to /etc/resolv.conf in WSL2 linux
    Write-Output $resolvConf
    wsl -u root --distribution $wslHost -- echo "$resolvConf" ^> tee /etc/resolv.conf # > $null

}


### Main Script ###
function GetVPNAdapter {
    $vpnAdapter = Get-NetAdapter | Where-Object { ( $_.InterfaceDescription -like "*PANGP*" -or $_.InterfaceDescription -like "*Juniper Networks Virtual Adapter*" ) -and $_.Status -eq "Up" } | Select-Object -First 1
    return $vpnAdapter
}

function GetWSLAdapter {
    $wslAdapter = Get-NetIPAddress | Where-Object { $_.InterfaceAlias -eq "vEthernet (WSL)" -and $_.AddressFamily -eq "IPv4" }
    return $wslAdapter
}

$vpnAdapter = GetVPNAdapter
$wslAdapter = GetWSLAdapter

if ($vpnAdapter) {
    $vpnInterfaceNumber = $vpnAdapter.ifIndex
    $vpnDescription = $vpnAdapter.InterfaceDescription
}
else {
    Write-Output "PANGP or Pulse virtual adapter not found."
}

if ($wslAdapter) {
    $wslIPaddress = $wslAdapter.IPAddress
    $wslPrefixLength = $wslAdapter.PrefixLength
}
else {
    Write-Output "WSL adapter not found."
}


Write-Output "WSL Network Mask: $subnetMaskDottedDecimal"
Write-Output "VPN Interface Number: $vpnInterfaceNumber"
Write-Output "IP Address: $wslIPaddress"
Write-Output "Network Address: $wslNetworkAddress"
Write-Output "VPN Description: $vpnDescription`n"


$wslNetworkAddress = GetNetworkAddress -wslIPaddress $wslIPaddress -wslPrefixLength $wslPrefixLength -vpnInterfaceNumber $vpnInterfaceNumber -vpnDescription $vpnDescription
DeleteNetworkRoute -wslNetworkAddress $wslNetworkAddress -wslPrefixLength $wslPrefixLength -vpnInterfaceNumber $vpnInterfaceNumber